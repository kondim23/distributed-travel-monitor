Προγραμματισμός Συστήματος 2020-2021
Εργασία 2 
Κωνσταντίνος Δημητρακόπουλος 
ΑΜ: 1115201500034

Η εργασία μεταγλωτίζεται - συνδέεται με την εντολή 
make
ενώ εκτελείται με την εντολή 
./travelMonitor –m numMonitors -b bufferSize -s sizeOfBloom-i input_dir

Απαραίτητη προϋπόθεση είναι τα πεδία των records να ακολουθούν τις προϋποθεσεις της εκφώνησης, σχετικά με το αν
επιτρέπονται αριθμοί και άλλοι χαρακτήρες στα πεδία, αλλιώς απορίπτονται ως incosistent.

Για την δημιουργία της εργασίας χρησιμοποιήθηκαν τα αρχεία των διαλέξεων του μαθήματος και το man page της poll.

---------------------------------------------------------------------------------------------------------------------

travelMonitor.c:

Αρχικά δηλώνονται οι κατάλληλες ενέργειες για τους signals SIGINT, SIGQUIT, SIGCHLD. Τα set συμπληρώνονται με 
sigfillset. Κατα τα SIGINT, SIGQUIT καλείται η changeStatus_running όπου αλλάζει τη τιμή της μεταβλητής running σε 0
ώστε κατα τον επόμενο έλεγχο της το πρόγραμμα να μεταβεί σε κατάσταση τερματισμού. Κατα το SIGCHLD καλείται η
recreateChild για τη δημιουργία του νέου monitor.

Ο έλεγχος της μεταβλητής running  γίνεται κατάλληλα ώστε να μην διακοπεί μια εντολή ενός χρήστη πριν αυτή ολοκληρωθεί.
Συγκεκριμένα, γίνεται ακριβώς πριν και κατα την αναμονή του χρήστη για εντολή, αλλα και κατα την recreateChild ώστε 
να διαπιστωθεί αν το σημα SIGCHLD που έλαβε το parent process ήταν απο αποστολή σήματος SIGKILL απο το ίδιο το parent 
process στο monitor ή οχι.

Έπειτα γίνεται έλεγχος ορισμάτων του χρήστη, δημιουργουνται 2 pipes για καθε monitor (READ,WRITE) και γίνεται fork το 
κάθε monitor. Κατα την πρώτη εγγραφή-ανάγνωση στο pipe μεταβιβάζεται ένας integer (sizeof(int) bytes) που δηλώνει το
buffersize. Οι επόμενες εγγραφές-αναγνώσεις απο pipes γίνονται με τμήματα μεγέθους buffersize.

Επιπρόσθετα, μεταφέρεται το bloomsize στα monitors, διαβάζονται τα περιεχόμενα του inputDir, διαμοιράζονται οι 
κατάλογοι των χωρών στα monitors (round robin alphabetically - έχουν εισαχθεί αρχικά σε skipList ώστε να εξαχθούν με
τη σειρά αλφαβητικά), στέλνεται πληροφορία _COUNTRIES_END, γίνεται λήψη των bloom filters απο ta monitors με χρήση 
της poll ώστε να μην αναμένουμε κάποιο pipe να γράψει δεδομένα ενώ κάποιο άλλο έχει τελειώσει το γράψιμο. Στη συνέχεια
δεχόμαστε είσοδο απο το χρήστη.

Κατα την travelStatus δεχόμαστε τα ορίσματα, αναζητούμε τη χώρα στη skipList χωρών όπου είναι αποθηκευμένο το monitor id 
που την διαχειρίζεται και ελέγχουμε το bloom filter μέσω αυτού, Αν μπορεί να υπάρχει εμβολιασμός στέλνεται στο pipe του
monitor id αίτημα για _TRAVEL_REQ, το citizenID και το όνομα του ιού. Το monitor αποκρίνεται με YES [date] ή NO. Στην 
περίπτωση του YES ελέγχεται το διάστημα εμβολιασμού και στέλνεται ένα byte στο monitor μέσω pipe (0 για accept - 1 για 
reject). Τελικά εισάγεται το request στο requestHash για χρήση κατα τη travelStats.

Κατα τη travelStats δεχόμαστε τα ορίσματα του χρήστη, εφαρμόζουμε τη statistics_compute σε κάθε κόμβο του requestsHash
όπου ελέγχεται η χώρα, ο ιός, το διάστημα ημερομηνιών και η κατάσταση accept-reject του κάθε request που έχει συμβεί.

Κατα την addVaccinationRecords αρχικά δεχόμαστε τα ορίσματα του χρήστη, αναζητούμε τη χώρα και το monitor id στη skipList,
κατασκευάζουμε το path προς αναζήτηση του νέου αρχείου, στέλνεται σήμα SIGUSR1 στο κατάλληλο monitor και γράφεται στο pipe
το subdirectory path (ελαχιστοποιείται η αναζήτηση σε περίπτωση διαχείρισης πολλαπλών χωρών απο το monitor), αποδεσμεύεται
το παλιό hash απο bloom fitlers ανα ιό, διαβάζονται και αποθηκεύονται τα νέα bloom filters που προέκυψαν απο την ανάγνωση
στο pipe.

Κατα τη searchVaccinationStatus στέλνεται σε όλα τα monitors _VACSTAT_REQ αίτημα και το citizenID, με τη χρήση της poll
γίνεται ανάγνωση απο τα monitors, λαμβάνονται με τη σειρά τα στοιχεία προς ανάγνωση και τυπώνονται.

Κατα την terminateProgram αρχικά έχουμε δεχθεί σήμα SIGINT/SIGQUIT ή έχει δωθεί η εντολή /exit, στέλνεται SIGKILL σε κάθε
monitor (δεχόμαστε σήμα SIGCHLD αλλα αφού η τιμή running είναι ίση με 0 η recreateChild επιστρέφει), τυπώνονται οι
ζητούμενες πληροφορίες στο αρχείο log και αποδεσμεύεται η μνήμη.

Κατα τη recreateChild έχουμε δεχθεί σήμα SIGCHLD και επαναδημιουργουμε το monitor που απέτυχε. Εντοπίζεται το monitor
στον πίνακα monitor_pid και πραγματοποιείται η ίδια διαδικασία όπως στην αρχή του προγράμματος για κάθε monitor.

----------------------------------------------------------------------------------------------------------------------


monitor.c:

Αρχικά δηλώνονται οι κατάλληλες ενέργειες για τους signals SIGINT, SIGQUIT, SIGUSR1. Τα set συμπληρώνονται με 
sigfillset. Κατα τα SIGINT, SIGQUIT καλείται η write_log όπου τυπώνει στο αρχείο log πληροφορίες. Κατα το SIGUSR1
καλείται η changeStatus_newRecords όπου αλλάζει τη τιμή της μεταβλητής newRecords σε 1 ώστε κατα τον επόμενο έλεγχο
της το πρόγραμμα να πραγματοποιήσει αναζήτηση για νέο αρχείο εγγραφών.

Λαμβάνουμε απο το pipe το buffersize και bloomsize. Κατα την ανάγνωση του pipe δεχόμαστε όλες τις χώρες προς διαχείρηση,
τις αποθηκεύουμε σε skipList και για κάθε χώρα διαβάζουμε τα αρχεία που δεν έχουν προστεθεί στο σύστημα, και ενημερώνουμε
αυτό.

Ο έλεγχος της μεταβλητής newRecords  γίνεται κατάλληλα ώστε να μην διακοπεί μια εντολή ενός χρήστη πριν αυτή ολοκληρωθεί.
Συγκεκριμένα, γίνεται ακριβώς πριν και κατα την αναμονή του pipe για εντολή.

Λαμβάνουμε απο το pipe είτε _TRAVEL_REQ είτε _VACSTAT_REQ. Κατα το _TRAVEL_REQ υπάρχει αίτημα travelRequest, διαβάζουμε 
απο το pipe το citizenID και τον ιό και κατα την virus_searchRecordInVaccinatedType1 τυπώνεται στο pipe YES [date] ή
NO ανάλογα με τον εμβολιασμό του πολίτη. Τέλος λαμβάνεται ένα byte 0 ή 1 για accept ή reject του αιτήματος.

Κατα το _VACSTAT_REQ υπάρχει αίτημα searchVaccinationStatus, πραγματοποιείται αναζήτηση του χρήστη στο records hash,
Αν βρεθεί απο το monitor γράφονται τα στοιχεία του και για κάθε ιό που διαχειρίζεται το monitor γράφεται η κατάσταση
του χρήστη. Τέλος γράφεται _VACSTAT_END.

---------------------------------------------------------------------------------------------------------------------

pipe.c:

Οι συναρτήσεις read_from_pipe και write_to_pipe είναι όμοιες με τη διαφορά πως η πρώτη διαβάζει δεδομένα απο το pipe
σε πακέτα των buffer_size bytes, ενώ η δεύτερη ομοίως γράφει. Όσο δεν έχουν μεταφερθεί όλα τα bytes του μηνύματος,
μεταφέρεται κάθε φορά ένα μήνυμα το πολύ buffer_size bytes (αναλόγως με το πόσα bytes απομένουν στο αρχικό μήνυμα),
ενώ χειριζεται η περίπτωση όπου px ένα σήμα διακόπτει την ανάγνωση ενός πακέτου, με την εσωτερική επανάληψη, έως να 
μεταφερθούν bytes_to_write/bytes_to_read bytes (max sized buffer_size).

------------------------------------------------------------------------------------------------------------------------

create_infiles.sh:

Αρχικά γίνεται έλεγχος ορισμάτων, δημιουργείται το επιθυμητό directory, γίνεται αναζήτηση κάθε μοναδικής χώρας και
δημιουργείται υποκατάλογος για κάθε μία, δημιουργείται ένα προσωρινό αρχείο fileNum όπου αποθηκεύει ένα αριθμό απο
0 έως τον πλήθος των επιθυμητών infiles per directory, όπου και τα υποδεικνύει σε ποιό απο αυτά γίνεται εγγραφή κάθε
φορά. Διαβάζονται μία μία οι γραμμές-records απο το inputFile, βρίσκεται η χώρα που αναφέρεται και γράφονται κατάλληλα
στα αρχεια. Τέλος διαγράφονται τα fileNums.

------------------------------------------------------------------------------------------------------------------------

Τα υπόλοιπα είναι κοινά με της εργασίας 1.